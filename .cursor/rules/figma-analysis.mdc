---
description: Deep Figma analysis before implementing components
globs:
  - src/components/**/*.tsx
  - src/components/**/*.scss
alwaysApply: false
---

# Figma Analysis

Before implementing any component from Figma, complete ALL of these steps. Do not skip any.

## 1. Understand the structure

```
mcp_Figma_get_metadata(nodeId, fileKey)
```

From the XML output, extract:
- Layer hierarchy (what wraps what)
- Variant property names and values
- Sub-component instance names
- Auto-layout direction and spacing

## 2. Get tokens

```
mcp_Figma_get_variable_defs(nodeId, fileKey)
```

**Mirror Figma exactly:**
- If Figma uses a token → use that token in code
- If Figma uses a raw value → use that raw value in code

Do not invent tokens. Do not force token usage where the design uses a custom value.

## 3. Extract CSS for EACH variant

Run `get_design_context` on each variant node, not just the parent:
- Default state
- Each size variant (sm, md, lg)
- Each color/type variant
- Disabled state
- Hover/active states (if designed)

## 4. Identify component composition

For compound components (combobox, select, dialog, etc.), identify:

- **Which design system components appear inside?** (e.g., Chip inside Combobox)
- **How do they connect?** (e.g., Chip displays selected values)
- **Are they the same component or a variant?** (e.g., Combobox chip may be smaller than standalone Chip)

If a component uses another design system component:
1. Note which component it uses
2. Note any size/variant differences
3. Plan to use the existing component via `render` prop or composition

## 5. Document before coding

Before writing any code, output a summary:

```
## {Component} Analysis

**Variants**: {list all property:value pairs}
**Sizes**: {dimensions per size}
**Tokens used**:
  - Spacing: {list}
  - Colors: {list per state}
  - Radius: {value}
  - Typography: {mixin name}

**Sub-components**: {list any nested components}
**Composed components**: {list design system components used inside}
**States**: {list interactive states}
```

Only proceed to implementation after this summary is complete.

## When to go deeper

If the component has:
- **Nested components** → Get metadata of each sub-component
- **Multiple variants** → Get design context for each variant separately
- **Interactive states** → Confirm all states are designed, ask if any are missing
- **Design system components inside** → Analyze if they're the same or a size variant

## Red flags to catch

- Code using a raw value where Figma uses a token
- Code using a token where Figma uses a raw value
- Inconsistent values between variants that aren't in the design
- Missing states in design (disabled, focus) — ask before implementing
- Sub-components with their own variant logic (need separate analysis)
- Recreating a design system component instead of composing it
- Not understanding how child parts interact in compound components

## Figma vs Code translations

Some Figma structures are UX accommodations for designers, not design requirements. Translate these appropriately:

- **Wrapper frames around text** → Figma can't apply padding to text; in code, apply padding directly to the element
- **Styled frames instead of component instances** (e.g., Input styling inlined in Field) → nested instance props are harder to access in Figma; in code, slot in the actual component (`<Input />`)
