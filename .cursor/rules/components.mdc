---
description: Component implementation rules
globs:
  - src/components/**/*.tsx
  - src/components/**/*.scss
alwaysApply: false
---

# Component Implementation

## Decision Tree

1. **Does Base UI have it?** → Wrap it (Path A/B)
2. **No Base UI equivalent?** → Build custom (Path C)

## Base UI Research

1. **Discovery**: `https://base-ui.com/llms.txt` — what components exist
2. **Full docs**: `https://base-ui.com/react/components/{name}.md` — examples, API, props
3. **Find matching examples**: If Base UI has an example for your use case (e.g., multi-select, async search), reference that example's structure first
4. **Avoid browsing the website** — browser snapshots don't show code; use `.md` URLs directly

## Before Writing Code

1. Deep Figma analysis — follow `figma-analysis.mdc`
2. Check Base UI docs (`.md` URL) for existing component or composable primitives
3. **Find a matching example** — if one exists, use it as your structural reference
4. **For compound components**: Understand how child parts interact (see below)
5. For custom: check WAI-ARIA APG for accessibility requirements
6. **Write tests first** — define expected behavior before implementation

## Compound Components (Path A/B)

When wrapping Base UI compound components (Combobox, Select, Dialog, Menu, etc.):

1. **Read the Base UI docs** for each sub-part you'll expose
2. **Understand data flow**: Which part provides data? Which renders it?
   - Example: `Combobox.Value` provides selected values, `Combobox.Chips` is just a container
3. **Check render function patterns**: Does the part accept `children` as a function?
   - Example: `Combobox.List` → `{(item) => <Item />}` ✓
   - Example: `Combobox.Chips` → does NOT accept render function ✗
4. **Document in JSDoc**: Show correct usage, not assumed patterns

**Red flag**: Documenting a render function pattern without verifying the Base UI API supports it

## Base UI Wrapper Type Safety

When wrapping Base UI components, **check the actual types** before defining your interface:

```bash
# Check the Base UI component's type definition
cat node_modules/@base-ui/react/{component}/{part}/{Part}.d.ts
```

**Key questions:**
1. **Does it render an element?** Check if it's `ForwardRefExoticComponent` and what element type
2. **Can it forward refs?** Some Base UI parts are context providers (no ref support)
3. **What element type?** Match your `HTMLAttributes<T>` to the actual rendered element

**Common patterns:**
```tsx
// Renders <span>, forwards ref - ✓ wrap normally
export const ComboboxItemIndicator: ForwardRefExoticComponent<... & RefAttributes<HTMLSpanElement>>

// Context provider, no element - ✗ cannot forward ref/className
export function ComboboxValue(props: ComboboxValueProps): ReactElement
```

**If Base UI component is a context provider:**
- Wrap it in your own element (`<span>`) to enable ref/className
- Only pass props it actually accepts

## Rules

- Zero hardcoded values — use tokens from `_variables.scss`
- Use `@include` mixins from `_text-styles.scss` for typography
- Use `clsx` for className merging
- Use `forwardRef` with named function (not arrow)
- Use slots (`React.ReactNode` props) for nested elements
- Props spread last (consumer wins)

## Testing (TDD)

Write tests before implementation:

| Path | Tests |
|------|-------|
| A/B (wrapper) | Playwright CT only |
| C (custom) | Playwright CT (unit tests only if complex logic) |

Run: `npm run test`

## File Structure (creation order)

```
src/components/{Name}/
├── {Name}.test-stories.tsx  # 1. Test fixtures first
├── {Name}.test.tsx          # 2. Tests second
├── {Name}.tsx or parts.tsx  # 3. Implementation (make tests pass)
├── {Name}.module.scss       # 4. Styles
├── {Name}.stories.tsx       # 5. Storybook
└── index.ts                 # 6. Exports
```

## Pre-Commit Verification

**Always run production build before committing:**

```bash
npm run build
```

Dev mode TypeScript is lenient. Production build catches:
- Props passed to components that don't accept them
- Element type mismatches in interfaces
- Import resolution issues

## Checklist

- [ ] Figma analysis complete
- [ ] Tests written first
- [ ] Implementation makes tests pass
- [ ] Figma values mirrored exactly
- [ ] forwardRef + clsx
- [ ] **Base UI types verified** (check `.d.ts` files)
- [ ] **Production build passes** (`npm run build`)
- [ ] Reduced motion: `@media (prefers-reduced-motion: reduce)`
- [ ] Storybook story added
