---
description: Component implementation rules
globs:
  - src/components/**/*.tsx
  - src/components/**/*.scss
alwaysApply: false
---

# Component Implementation

## Decision Tree

1. **Does Base UI have it?** → Wrap it (Path A/B)
2. **No Base UI equivalent?** → Build custom (Path C)

**Base UI Research**: Start at https://base-ui.com/llms.txt — full component list and docs.

## Before Writing Code

1. Deep Figma analysis — follow `figma-analysis.mdc`
2. Check Base UI for existing component or composable primitives
3. **For compound components**: Understand how child parts interact (see below)
4. For custom: check WAI-ARIA APG for accessibility requirements
5. **Write tests first** — define expected behavior before implementation

## Compound Components (Path A/B)

When wrapping Base UI compound components (Combobox, Select, Dialog, Menu, etc.):

1. **Read the Base UI docs** for each sub-part you'll expose
2. **Understand data flow**: Which part provides data? Which renders it?
   - Example: `Combobox.Value` provides selected values, `Combobox.Chips` is just a container
3. **Check render function patterns**: Does the part accept `children` as a function?
   - Example: `Combobox.List` → `{(item) => <Item />}` ✓
   - Example: `Combobox.Chips` → does NOT accept render function ✗
4. **Document in JSDoc**: Show correct usage, not assumed patterns

**Red flag**: Documenting a render function pattern without verifying the Base UI API supports it

## Rules

- Zero hardcoded values — use tokens from `_variables.scss`
- Use `@include` mixins from `_text-styles.scss` for typography
- Use `clsx` for className merging
- Use `forwardRef` with named function (not arrow)
- Use slots (`React.ReactNode` props) for nested elements
- Props spread last (consumer wins)

## Testing (TDD)

Write tests before implementation:

| Path | Tests |
|------|-------|
| A/B (wrapper) | Playwright CT only |
| C (custom) | Playwright CT (unit tests only if complex logic) |

Run: `npm run test`

## File Structure (creation order)

```
src/components/{Name}/
├── {Name}.test-stories.tsx  # 1. Test fixtures first
├── {Name}.test.tsx          # 2. Tests second
├── {Name}.tsx or parts.tsx  # 3. Implementation (make tests pass)
├── {Name}.module.scss       # 4. Styles
├── {Name}.stories.tsx       # 5. Storybook
└── index.ts                 # 6. Exports
```

## Checklist

- [ ] Figma analysis complete
- [ ] Tests written first
- [ ] Implementation makes tests pass
- [ ] Figma values mirrored exactly
- [ ] forwardRef + clsx
- [ ] Reduced motion: `@media (prefers-reduced-motion: reduce)`
- [ ] Storybook story added
